
/* # de libros distintos que maneja la editorial */
const NBOOKS = 2
range NumBooks = 0..NBOOKS-1

/* Existencias máximas posibles para un libro */
const BMAX = 2
range Copies = 0..BMAX

/* Precio genérico de un librito */
const BPRICE = 2

/* # de clientes simultáneos */
const CMAX = 2
range NumClients = 0..CMAX-1

/* Saldo inicial de un cliente */
const SMAX = 2



/******************************************************************************/
/*******************************   Libros   ***********************************/

/* Un librito */
BOOK = BOOK[BMAX],
BOOK[i:Copies] = (ask.existence[i] -> BOOK[i]
                 |when (i>0)  buy  -> BOOK[i-1]).

/* Candado de acceso a las copias de ese librito */
LOCK = (acquire -> release -> LOCK).

||BOOKS = (book[NumBooks]:BOOK || book.lock[NumBooks]:LOCK).



/******************************************************************************/
/******************************   Clientes   **********************************/

/* Un cliente */
CLIENT = (request.book[b:NumBooks] -> (accepted[b] -> CLIENT
                                      |rejected[b] -> CLIENT)
         |ask.balance[s:0..SMAX]                   -> CLIENT).

/* Su tarjeta de crédito */
CARD = CARD[SMAX],
CARD[i:0..SMAX] = (ask.balance[i]       -> CARD[i]
                  |owner.ask.balance[i] -> CARD[i]
                  |extract[j:0..SMAX]
                   -> if (j <= i) then CARD[i-j]
                                  else CARD[i]
                  ).

/* Clientela */
||CLIENTS = (     client[NumClients]:CLIENT
            ||      card[NumClients]:CARD
            || card.lock[NumClients]:LOCK
            )

  /{ forall[c:NumClients] {
         forall[s:0..SMAX] {
            client[c].ask.balance[s] / card[c].owner.ask.balance[s]
         }
     }
   }.



/******************************************************************************/
/**************************   Tienda de libros   ******************************/

/* Controlador de compra de (copias de) un libro */
BOOK_CTRL = (request.book
             -> book.lock.acquire
             -> ask.existence[e:0..BMAX]
             -> if (e>0)
                then (
                     card.lock.acquire
                     /* No hay deadlock pues un cliente puede comprar
                      * un libro a la vez, y cada libro puede ser comprado
                      * por un cliente a la vez */
                     -> card.ask.balance[s:0..SMAX]
                     -> if (s >= BPRICE)
                        then
                             ( accept
                             -> extract[BPRICE]
                             -> buy
                             -> card.lock.release
                             -> book.lock.release
                             -> BOOK_CTRL)
                        else
                            ( reject
                             -> card.lock.release
                             -> book.lock.release
                             -> BOOK_CTRL)
                ) else (
                        reject
                     -> book.lock.release
                     -> BOOK_CTRL
                )
            ) + {extract[0..SMAX]}.

/* Controlador de todos los libritos (en paralelo) */
||BSTORE = (bs[NumBooks]:BOOK_CTRL).



/******************************************************************************/
/*******************************   Sistema  ***********************************/


/* TODO:
 *      Hay problemas de acceso incorrecto (no restringido) a tarjetas
 *      Cuando un cliente está comprando un libro
 *      y en el proceso BOOK_CTRL llega a la instancia "card.lock.acquire"
 *      se le habilitan ambos locks: el suyo y el del otro cliente */


||SYSTEM = (CLIENTS || cl[NumClients]::BSTORE || BOOKS)

  /{ /* Coordinamos las acciones de la tienda con todos ... */
     forall[c:NumClients] {

         forall[b:NumBooks] {

             /* ... del cliente con la tienda */
             client[c].request.book[b]  / cl[c].bs[b].request.book,
             client[c].accepted[b]      / cl[c].bs[b].accept,
             client[c].rejected[b]      / cl[c].bs[b].reject,

             /* ... de la tienda con la tarjeta */
             forall[s:0..SMAX] {
                 card[c].ask.balance[s] / cl[c].bs[b].card.ask.balance[s],
                 card[c].extract[s]     / cl[c].bs[b].extract[s],
                 card.lock[c].acquire   / cl[c].bs[b].card.lock.acquire,
                 card.lock[c].release   / cl[c].bs[b].card.lock.release
             },

             /* ... de la tienda con los libros */
             book.lock[b].acquire / cl[c].bs[b].book.lock.acquire,
             book.lock[b].release / cl[c].bs[b].book.lock.release,
             book[b].buy          / cl[c].bs[b].buy,
             forall[e:Copies] {
                 book[b].ask.existence[e] / cl[c].bs[b].ask.existence[e]
             }
         }
     }
   }.
